This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T21:21:14.284Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
cline_docs/
  activeContext.md
  debug-plan.md
  productContext.md
  progress.md
  systemPatterns.md
  techContext.md
config/
  config.js
  videoConfig.js
controllers/
  UIController.js
  VideoControllerFactory.js
utils/
  ErrorHandler.js
  EventEmitter.js
  helpers.js
  performance.js
workers/
  frameAnalyzer.worker.js
.clinerules
app.js
index.html
styles.css
uiController.js
videoController.js
videoSources.js

================================================================
Files
================================================================

================
File: cline_docs/activeContext.md
================
# Active Context

## Current Status
- Initial codebase setup complete
- Core video player functionality implemented
- UI controls and interaction system in place
- IPFS provider management system operational

## Recent Changes
1. Implemented buffer recovery system
2. Added dynamic UI theming based on video content
3. Created gesture-based interaction system
4. Implemented smart notification system
5. Added preloading mechanism for smoother playback

## Next Steps
1. **Performance Optimization**
   - Review frame analysis efficiency
   - Optimize memory usage during provider switching
   - Improve buffering prediction
   - Implement more efficient frame sampling
   - Add request caching for IPFS providers

2. **Feature Enhancements**
   - Add quality selection options
   - Implement playback speed controls
   - Add playlist management
   - Introduce chapter markers
   - Support for subtitles/captions

3. **Reliability Improvements**
   - Enhance provider failover logic
   - Implement more sophisticated buffering strategies
   - Add detailed error reporting
   - Improve network condition detection
   - Add retry mechanisms for failed requests

## Current Focus
- Optimizing video buffering and recovery mechanisms
- Improving user interaction feedback
- Enhancing provider switching logic
- Implementing more robust error handling
- Adding comprehensive progress tracking

================
File: cline_docs/debug-plan.md
================
# Video Player Debug Plan

## Current Issues

1. **Missing Buffer Recovery System**
- Buffer recovery logic from commit 8aa42e8 not present in current codebase
- No handling of buffer stalls
- Missing provider failover mechanism

2. **Broken Component Integration**
- VideoSourceManager not properly connected to VideoController
- Event system between components incomplete
- UI controls not fully integrated

3. **Missing Scroll UX Features**
- Seeking state management incomplete
- Gesture handling not implemented
- Progress bar interaction issues

## Required Changes

### app.js Updates
1. Restore buffer recovery system:
```javascript
let isSeeking = false;
let isRecovering = false;
let bufferingUpdateScheduled = false;
```

2. Add seeking state management:
```javascript
video.addEventListener('seeking', () => {
  isSeeking = true;
  if (controlsSystem) controlsSystem.handleBufferingStart(true);
});

video.addEventListener('seeked', () => {
  isSeeking = false;
  if (controlsSystem) controlsSystem.handleBufferingEnd();
});
```

3. Implement provider indices management:
```javascript
const providerIndices = new Map();
```

### VideoController Integration
1. Connect VideoSourceManager:
```javascript
constructor(videoElement, providers = []) {
  this.video = videoElement;
  this.providers = providers;
  this.sourceManager = videoSourceManager;
}
```

2. Add buffer recovery logic:
```javascript
async handleBufferRecovery() {
  if (isRecovering) return;
  isRecovering = true;
  // Recovery logic from commit
}
```

### UI Controller Updates
1. Enhance progress bar handling:
```javascript
handleProgressMouseDown(e) {
  e.preventDefault();
  this.state.isDragging = true;
  isSeeking = true;
}
```

2. Add scroll UX improvements:
```javascript
wrapper.addEventListener('pointerdown', handler, { passive: false });
wrapper.addEventListener('pointermove', throttle(handler, 32), { passive: true });
```

## Implementation Steps

1. Switch to Code mode to implement changes in app.js
2. Update VideoController with proper provider integration
3. Enhance UIController with scroll UX improvements
4. Test buffer recovery and seeking functionality
5. Verify component integration

## Testing Plan

1. **Buffer Recovery**
- Simulate network issues
- Verify provider failover
- Check buffer visualization

2. **Seeking Functionality**
- Test progress bar interaction
- Verify timestamp updates
- Check gesture controls

3. **Component Integration**
- Verify event flow
- Test state management
- Check UI updates

## Expected Result

The video player should:
1. Handle buffer stalls gracefully with recovery
2. Provide smooth seeking experience
3. Show accurate buffer/progress visualization
4. Maintain proper state during user interactions

================
File: cline_docs/productContext.md
================
# Product Context

## Purpose
This project is a specialized web-based video player designed to stream content from IPFS (InterPlanetary File System) with robust failover capabilities. It aims to provide a reliable and user-friendly video streaming experience while leveraging decentralized storage.

## Problems Solved
1. **IPFS Gateway Reliability**
   - Handles gateway failures through automatic provider switching
   - Implements smart provider selection with caching of reliable providers
   - Provides seamless recovery from buffering issues

2. **Video Playback Performance**
   - Optimizes buffering and preloading mechanisms
   - Implements efficient frame analysis for UI theming
   - Manages memory usage through strategic resource cleanup

3. **User Experience**
   - Offers intuitive gesture-based controls
   - Provides responsive visual feedback
   - Maintains consistent playback during network issues

## Core Functionality
- Multi-provider IPFS video streaming
- Adaptive video buffering and recovery
- Dynamic UI theming based on video content
- Gesture and keyboard-based controls
- Advanced seeking and timestamp preview
- Smart notification system
- Fullscreen support with auto-hiding controls

## Target Usage
The application is designed for:
- Streaming video content hosted on IPFS
- Supporting multiple video formats
- Operating across different devices and browsers
- Providing a YouTube-like experience for decentralized content

## Success Metrics
- Minimal playback interruptions
- Fast recovery from gateway failures
- Smooth seeking and navigation
- Responsive UI controls
- Efficient resource usage
- Cross-browser compatibility

================
File: cline_docs/progress.md
================
# Progress Tracking

## Completed Features

### Core Video Player
- [x] Basic video playback implementation
- [x] IPFS provider integration
- [x] Provider failover system
- [x] Buffer management
- [x] Preloading mechanism

### User Interface
- [x] Custom video controls
- [x] Progress bar with preview
- [x] Gesture-based interactions
- [x] Keyboard shortcuts
- [x] Fullscreen support
- [x] Notification system
- [x] Dynamic theming

### Performance
- [x] Frame analysis optimization
- [x] Web Worker implementation
- [x] Throttled updates
- [x] Resource cleanup
- [x] Memory management

### Error Handling
- [x] Provider switching
- [x] Buffer recovery
- [x] Playback state preservation
- [x] Error notifications
- [x] Connection recovery

## In Progress

### Performance Optimization
- [ ] Further frame analysis optimization
- [ ] Smarter preloading strategies
- [ ] Enhanced buffer management
- [ ] Reduced CPU usage
- [ ] Better memory utilization

### Feature Implementation
- [ ] Quality selection
- [ ] Playback speed control
- [ ] Playlist support
- [ ] Chapter markers
- [ ] Subtitle support

### Reliability Improvements
- [ ] Advanced provider rating
- [ ] Smart fallback system
- [ ] Network condition detection
- [ ] Predictive buffering
- [ ] Enhanced error recovery

## Planned Features

### User Experience
- [ ] Custom playlists
- [ ] Video thumbnails
- [ ] Advanced gesture controls
- [ ] Picture-in-picture mode
- [ ] Mobile optimization

### Technical Enhancements
- [ ] Service Worker integration
- [ ] Progressive Web App features
- [ ] Advanced caching
- [ ] Offline support
- [ ] Background playback

### Analytics & Monitoring
- [ ] Performance metrics
- [ ] Usage statistics
- [ ] Error tracking
- [ ] Provider performance monitoring
- [ ] Quality of service metrics

## Known Issues

### Performance
1. High CPU usage during frame analysis
2. Memory spikes during provider switching
3. Buffer issues on slow connections
4. Frame drops during theme transitions

### Compatibility
1. Limited mobile browser support
2. Inconsistent codec support
3. CORS issues with some providers
4. Varying fullscreen behavior

### User Experience
1. Delayed provider switching
2. Occasional buffering hiccups
3. Theme flicker on some videos
4. Notification stacking issues

## Progress Metrics

### Core Functionality
- Video Playback: 100%
- Provider Integration: 90%
- Buffer Management: 85%
- Error Handling: 80%

### User Interface
- Controls: 95%
- Gestures: 90%
- Notifications: 85%
- Theming: 80%

### Performance
- Frame Analysis: 75%
- Memory Usage: 70%
- CPU Utilization: 65%
- Network Efficiency: 80%

## Next Steps Priority

### High Priority
1. Optimize frame analysis
2. Improve buffer management
3. Enhance provider switching
4. Fix mobile compatibility

### Medium Priority
1. Implement quality selection
2. Add playback speed control
3. Improve error recovery
4. Enhance notifications

### Low Priority
1. Add playlist support
2. Implement chapters
3. Add subtitle support
4. Enhance analytics

================
File: cline_docs/systemPatterns.md
================
# System Patterns

## Architecture Overview

### Core Components
1. **Video Controller**
   - Manages video playback and state
   - Handles provider switching and recovery
   - Controls buffering and preloading
   - Implements retry mechanisms

2. **UI Controller**
   - Manages user interface elements
   - Handles user interactions
   - Controls visual feedback
   - Manages notifications
   - Updates progress indicators

3. **Frame Analyzer**
   - Processes video frames
   - Extracts dominant colors
   - Provides theme data
   - Optimizes performance through web workers

### Design Patterns

1. **Observer Pattern**
   - Event-based communication between components
   - Video state monitoring
   - UI updates based on playback state
   - Buffer state tracking

2. **State Machine**
   - Video player states (playing, paused, buffering)
   - Loading states
   - Provider switching states
   - Recovery states

3. **Strategy Pattern**
   - Provider selection
   - Buffer management
   - Frame analysis methods
   - Error recovery strategies

4. **Factory Pattern**
   - UI element creation
   - Notification generation
   - Control element instantiation

5. **Singleton Pattern**
   - Video controller instance
   - UI controller instance
   - Frame analyzer instance

## Technical Decisions

### Performance Optimizations
1. **Frame Analysis**
   - Reduced sampling resolution
   - Web Worker implementation
   - Throttled updates
   - Optimized pixel data processing

2. **Resource Management**
   - Strategic preloading
   - Garbage collection triggers
   - Memory leak prevention
   - Resource cleanup on state changes

3. **UI Optimizations**
   - CSS transitions for smooth animations
   - Throttled event handlers
   - Efficient DOM updates
   - Hardware acceleration

### Error Handling
1. **Provider Failover**
   - Smart provider selection
   - Automatic recovery
   - Cached provider ratings
   - Progressive timeout strategy

2. **Buffer Management**
   - Predictive buffering
   - Recovery mechanisms
   - State preservation
   - Quality adaptation

### Code Organization
1. **Module Structure**
   - Separate concerns (UI, video, analysis)
   - Clear dependencies
   - Encapsulated functionality
   - Easy maintenance

2. **Event System**
   - Centralized event handling
   - Debounced listeners
   - Clear event hierarchy
   - Performance monitoring

## Implementation Details

### Key Classes
1. **UIController**
   - Manages all UI interactions
   - Handles visual updates
   - Controls user feedback
   - Manages state display

2. **VideoController**
   - Controls video playback
   - Manages providers
   - Handles buffering
   - Controls quality

3. **FrameAnalyzer**
   - Processes video frames
   - Extracts color data
   - Optimizes processing
   - Provides theme updates

### Critical Flows
1. **Video Loading**
   ```
   User Action → Load Request → Provider Selection →
   Buffer Check → Quality Selection → Playback Start
   ```

2. **Error Recovery**
   ```
   Error Detection → State Preservation → Provider Switch →
   Buffer Recovery → State Restoration → Resume Playback
   ```

3. **Theme Updates**
   ```
   Frame Capture → Worker Processing → Color Extraction →
   Theme Generation → UI Update
   ```

## Future Considerations

### Scalability
1. **Provider Management**
   - Dynamic provider discovery
   - Load balancing
   - Geographic optimization
   - Performance tracking

2. **Feature Extension**
   - Plugin architecture
   - API standardization
   - Module system
   - Configuration management

### Maintenance
1. **Code Quality**
   - Consistent patterns
   - Clear documentation
   - Test coverage
   - Performance monitoring

2. **Updates**
   - Version control
   - Breaking changes
   - Migration paths
   - Backward compatibility

================
File: cline_docs/techContext.md
================
# Technical Context

## Technology Stack

### Frontend
- **Core Technologies**
  - HTML5 Video API
  - JavaScript (ES6+)
  - CSS3 with CSS Variables
  - Web Workers API

- **Browser APIs**
  - Canvas API (frame analysis)
  - Fullscreen API
  - Pointer Events API
  - Intersection Observer
  - ResizeObserver

### Infrastructure
- **Content Delivery**
  - IPFS Gateway Network
  - Multiple Provider Support
  - Fallback Systems

### Performance Features
- **Video Optimization**
  - Adaptive Buffering
  - Smart Preloading
  - Frame Analysis
  - Provider Switching

- **UI Performance**
  - Hardware Acceleration
  - Throttled Updates
  - Efficient DOM Operations
  - Optimized Event Handling

## Development Setup

### Required Tools
- Modern Web Browser
- Text Editor/IDE with JavaScript support
- Local Development Server
- Git Version Control

### Development Environment
```javascript
// Browser Requirements
- ES6+ Support
- HTML5 Video
- WebWorker Support
- Canvas API
- Modern CSS Features

// Development Tools
- ESLint Configuration
- Browser Developer Tools
- Performance Monitoring
- Network Analysis Tools
```

### Building and Testing
- No build process required (vanilla JavaScript)
- Direct browser testing
- DevTools for performance analysis
- Network throttling for testing

## Technical Constraints

### Browser Support
- Modern browsers only (Chrome, Firefox, Safari, Edge)
- ES6+ JavaScript features required
- HTML5 Video API support needed
- Canvas API support required

### Performance Requirements
- Smooth video playback (60fps target)
- Minimal memory footprint
- Efficient frame analysis
- Fast provider switching
- Responsive UI updates

### Network Considerations
- Variable IPFS gateway performance
- Multiple provider handling
- Bandwidth optimization
- Connection recovery
- Buffering management

### Security Constraints
- CORS compliance required
- Safe frame extraction
- Secure provider handling
- Resource validation

## Dependencies
- No external JavaScript libraries
- Native browser APIs only
- IPFS gateway network
- HTML5 video capabilities

## Integration Points
- IPFS Gateway Network
- Browser Video API
- Canvas Processing
- Web Workers
- Local Storage

## Monitoring & Debugging
- Console Logging System
- Performance Metrics
- Error Tracking
- Network Monitoring
- State Management

## Known Limitations
1. **Browser Support**
   - Modern browsers only
   - Limited mobile optimization
   - Varying codec support

2. **Performance**
   - CPU-intensive frame analysis
   - Memory usage during preloading
   - Network dependency
   - Gateway reliability

3. **Features**
   - No DRM support
   - Limited format support
   - Gateway restrictions
   - Buffer size limits

## Future Technical Considerations
1. **Improvements**
   - Service Worker integration
   - Progressive Web App features
   - Advanced caching strategies
   - Better mobile support

2. **Optimizations**
   - Reduced CPU usage
   - Better memory management
   - Smarter preloading
   - Enhanced error recovery

3. **Features**
   - Custom codec support
   - Advanced DRM options
   - Better mobile experience
   - Offline capabilities

================
File: config/config.js
================
// Core configuration settings

export const PROVIDERS = {
  list: ['ipfs.io', 'algonode.xyz', 'eth.aragon.network', 'dweb.link', 'flk-ipfs.xyz'],
  displayNames: {
    'ipfs.io': 'IPFS Gateway',
    'algonode.xyz': 'Algonode',
    'eth.aragon.network': 'Aragon',
    'dweb.link': 'IPFS',
    'flk-ipfs.xyz': 'Fleek'
  }
};

export const VIDEO = {
  CACHE_KEY: 'videoCache',
  CID_VALID_CACHE_KEY: 'validCidCache',
  CID_VALIDITY_DURATION: 48 * 60 * 60 * 1000, // 48 hours
  LOAD_TIMEOUT: 2000, // 2 seconds
  BUFFER_CHECK_DELAY: 1000 // 1 second
};

export const UI = {
  CONTROLS_TIMEOUT: 3000, // 3 seconds of inactivity
  TIMESTAMP_OFFSET_BOTTOM: 20, // px from progress bar
  POPUP_TRANSITION_DURATION: 0.05, // seconds
  MULTI_TAP_DELAY: 200, // ms between taps
  SAMPLING: {
    WIDTH: 32,
    HEIGHT: 32,
    PIXEL_STEP: 16
  }
};

export const PERFORMANCE = {
  THROTTLE: {
    PROGRESS: 66, // ~15fps
    BUFFER: 100, // 10fps
    HUE: 200 // 5fps
  },
  PRELOAD: {
    TIMEOUT: 4000 // 4 seconds
  }
};

export const ERRORS = {
  MAX_RETRIES: 3,
  RETRY_DELAY: 1000 // 1 second
};

================
File: config/videoConfig.js
================
/**
 * Video player configuration settings
 */

export const VIDEO_SETTINGS = {
    // Playback settings
    DEFAULT_VOLUME: 1.0,
    DEFAULT_PLAYBACK_RATE: 1.0,
    SEEK_STEP: 10, // seconds
    VOLUME_STEP: 0.1,
    MIN_VOLUME: 0,
    MAX_VOLUME: 1,

    // Buffer settings
    MINIMUM_BUFFER: 2, // seconds
    OPTIMAL_BUFFER: 10, // seconds
    MAX_BUFFER_SIZE: 50 * 1024 * 1024, // 50MB
    BUFFER_CHECK_INTERVAL: 1000, // ms
    BUFFER_STALL_TIMEOUT: 5000, // ms before triggering stall event

    // Provider settings
    MAX_PROVIDER_RETRIES: 3,
    PROVIDER_TIMEOUT: 10000, // ms
    MIN_PROVIDER_SCORE: 0.1,
    PROVIDER_SCORE_DECAY: 0.95,

    // Frame analysis settings
    FRAME_ANALYSIS: {
        TARGET_FPS: 30,
        MIN_FRAME_INTERVAL: 1000 / 30, // ms
        SAMPLE_SIZE: {
            WIDTH: 32,
            HEIGHT: 32
        },
        COLOR_ANALYSIS: {
            MIN_BRIGHTNESS: 0.1,
            MAX_BRIGHTNESS: 0.9,
            SATURATION_THRESHOLD: 0.1,
            TEMPORAL_SMOOTHING: 0.8
        }
    },

    // Cache settings
    CACHE: {
        MAX_AGE: 24 * 60 * 60 * 1000, // 24 hours
        MAX_ITEMS: 100,
        CLEANUP_INTERVAL: 60 * 60 * 1000 // 1 hour
    },

    // Error handling
    ERROR_HANDLING: {
        MAX_RETRIES: 3,
        RETRY_DELAY: 1000, // ms
        FATAL_ERROR_CODES: [
            MediaError.MEDIA_ERR_ABORTED,
            MediaError.MEDIA_ERR_NETWORK,
            MediaError.MEDIA_ERR_DECODE,
            MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED
        ]
    },

    // Media source settings
    MSE: {
        SEGMENT_DURATION: 2, // seconds
        BUFFER_SIZE: 30, // seconds
        MIME_TYPES: {
            MP4: 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"',
            WEBM: 'video/webm; codecs="vp8,vorbis"'
        }
    },

    // Network settings
    NETWORK: {
        CHUNK_SIZE: 1024 * 1024, // 1MB
        CONCURRENT_CHUNKS: 3,
        BANDWIDTH_ESTIMATION_TIME: 5000, // ms
        MIN_BANDWIDTH: 500 * 1024, // 500kbps
        LOW_BANDWIDTH_THRESHOLD: 1.5 * 1024 * 1024 // 1.5Mbps
    },

    // Quality settings
    QUALITY: {
        AUTO_QUALITY_INTERVAL: 5000, // ms
        BUFFER_THRESHOLD_LOW: 5, // seconds
        BUFFER_THRESHOLD_HIGH: 15, // seconds
        QUALITY_LEVELS: [
            { bitrate: 400000, height: 360 },
            { bitrate: 800000, height: 480 },
            { bitrate: 1500000, height: 720 },
            { bitrate: 3000000, height: 1080 }
        ]
    },

    // Analytics settings
    ANALYTICS: {
        SAMPLE_INTERVAL: 1000, // ms
        METRICS: {
            BUFFER_OCCUPANCY: true,
            PLAYBACK_QUALITY: true,
            FRAME_DROPS: true,
            ERROR_RATE: true,
            BANDWIDTH_USAGE: true
        }
    }
};

/**
 * Supported video formats
 */
export const SUPPORTED_FORMATS = [
    {
        extension: 'mp4',
        mimeType: 'video/mp4',
        codecs: ['avc1.42E01E', 'mp4a.40.2']
    },
    {
        extension: 'webm',
        mimeType: 'video/webm',
        codecs: ['vp8', 'vorbis']
    },
    {
        extension: 'mov',
        mimeType: 'video/quicktime'
    }
];

/**
 * Error messages
 */
export const ERROR_MESSAGES = {
    NETWORK_ERROR: 'Network error occurred while loading the video',
    DECODE_ERROR: 'Error occurred while decoding the video',
    NOT_SUPPORTED: 'Video format is not supported',
    ABORTED: 'Video loading was aborted',
    PROVIDER_ERROR: 'Error occurred while fetching from provider',
    BUFFER_STALL: 'Video playback stalled due to insufficient buffer',
    UNKNOWN_ERROR: 'An unknown error occurred'
};

/**
 * User interface text
 */
export const UI_TEXT = {
    PLAY: 'Play',
    PAUSE: 'Pause',
    MUTE: 'Mute',
    UNMUTE: 'Unmute',
    FULLSCREEN: 'Enter fullscreen',
    EXIT_FULLSCREEN: 'Exit fullscreen',
    SETTINGS: 'Settings',
    QUALITY: 'Quality',
    AUTO: 'Auto'
};

// Export all configurations
export default {
    VIDEO_SETTINGS,
    SUPPORTED_FORMATS,
    ERROR_MESSAGES,
    UI_TEXT
};

================
File: controllers/UIController.js
================
import eventEmitter from '../utils/EventEmitter.js';
import { throttle, debounce } from '../utils/performance.js';
import { UI } from '../config/config.js';

/**
 * Manages video player UI state and interactions
 */
class UIController {
  constructor(containerElement, wrapperElement) {
    this.container = containerElement;
    this.wrapper = wrapperElement;
    if (!this.wrapper) {
      throw new Error('Video wrapper element is required');
    }

    this.controlsVisible = true;
    this.userInteracting = false;
    this.lastInteraction = Date.now();
    this.state = {
      isDragging: false,
      isDraggingPopup: false,
      cachedRect: null
    };

    // UI Elements
    this.elements = {
      controls: null,
      progressContainer: null,
      progressBar: null,
      timestamp: null,
      timestampPopup: null,
      playButton: null,
      volumeSlider: null,
      fullscreenButton: null,
      bufferBar: null
    };

    this.initialize();
  }

  /**
   * Initialize the UI controller
   */
  initialize() {
    this.createUIElements();
    this.setupEventListeners();
    this.setupControlsTimeout();
  }

  /**
   * Create UI elements
   */
  createUIElements() {
    // Controls container
    this.elements.controls = document.createElement('div');
    this.elements.controls.className = 'video-controls';

    // Progress container
    this.elements.progressContainer = document.createElement('div');
    this.elements.progressContainer.className = 'progress-container';

    // Progress bar
    this.elements.progressBar = document.createElement('div');
    this.elements.progressBar.className = 'progress-bar';

    this.elements.bufferBar = document.createElement('div');
    this.elements.bufferBar.className = 'buffer-bar';
    this.elements.progressBar.appendChild(this.elements.bufferBar);

    // Timestamp popup
    this.elements.timestampPopup = document.createElement('div');
    this.elements.timestampPopup.className = 'timestamp-popup';
    this.elements.timestampPopup.style.display = 'none';

    // Regular timestamp
    this.elements.timestamp = document.createElement('div');
    this.elements.timestamp.className = 'timestamp';

    // Play button
    this.elements.playButton = document.createElement('button');
    this.elements.playButton.className = 'play-button';
    this.elements.playButton.setAttribute('aria-label', 'Play');

    // Volume slider
    this.elements.volumeSlider = document.createElement('input');
    this.elements.volumeSlider.type = 'range';
    this.elements.volumeSlider.className = 'volume-slider';
    this.elements.volumeSlider.min = '0';
    this.elements.volumeSlider.max = '1';
    this.elements.volumeSlider.step = '0.1';
    this.elements.volumeSlider.value = '1';

    // Fullscreen button
    this.elements.fullscreenButton = document.createElement('button');
    this.elements.fullscreenButton.className = 'fullscreen-button';
    this.elements.fullscreenButton.setAttribute('aria-label', 'Fullscreen');

    // Append elements
    this.elements.progressContainer.appendChild(this.elements.progressBar);
    this.elements.progressContainer.appendChild(this.elements.timestampPopup);

    this.elements.controls.appendChild(this.elements.playButton);
    this.elements.controls.appendChild(this.elements.volumeSlider);
    this.elements.controls.appendChild(this.elements.progressContainer);
    this.elements.controls.appendChild(this.elements.timestamp);
    this.elements.controls.appendChild(this.elements.fullscreenButton);

    this.wrapper.appendChild(this.elements.controls);
  }

  /**
   * Set up event listeners
   */
  setupEventListeners() {
    // Use unified pointer events for better scroll UX
    const handler = this.handleUnifiedPointerEvent.bind(this);
    
    // Use passive: false for pointerdown to allow preventDefault
    this.wrapper.addEventListener('pointerdown', handler, { passive: false });
    this.wrapper.addEventListener('pointermove', throttle(handler, 32), { passive: true });
    this.wrapper.addEventListener('pointerup', handler, { passive: true });
    this.wrapper.addEventListener('pointercancel', handler, { passive: true });

    // Touch events
    let lastTap = 0;
    this.wrapper.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastTap < UI.MULTI_TAP_DELAY) {
        this.handleDoubleTap(e);
      }
      lastTap = now;
    });

    // Mouse movement
    this.wrapper.addEventListener('mousemove',
      throttle(this.handleMouseMove.bind(this), UI.CONTROLS_TIMEOUT / 3)
    );

    this.wrapper.addEventListener('mouseleave',
      () => this.hideControls()
    );

    // Playback controls
    this.elements.playButton.addEventListener('click', () => {
      eventEmitter.emit('video:toggle-play');
    });

    this.elements.volumeSlider.addEventListener('input',
      debounce((e) => eventEmitter.emit('video:volume-change', parseFloat(e.target.value)), 100)
    );

    this.elements.fullscreenButton.addEventListener('click', () => {
      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        this.wrapper.requestFullscreen();
      }
    });

    // Video events
    eventEmitter.on('video:timeupdate', this.updateProgress.bind(this));
    eventEmitter.on('video:buffer-update', this.updateBuffer.bind(this));
    eventEmitter.on('video:play', () => this.updatePlayButton(true));
    eventEmitter.on('video:pause', () => this.updatePlayButton(false));
  }

  /**
   * Handle unified pointer events
   * @param {PointerEvent} e - Pointer event
   */
  handleUnifiedPointerEvent(e) {
    // Ignore events not on progress container
    if (!e.target.closest('.progress-container')) {
      return;
    }

    switch (e.type) {
      case 'pointerdown':
        this.handlePointerDown(e);
        break;
      case 'pointermove':
        this.handlePointerMove(e);
        break;
      case 'pointerup':
      case 'pointercancel':
        this.handlePointerUp(e);
        break;
    }
  }

  /**
   * Handle pointer down
   * @param {PointerEvent} e - Pointer event
   */
  handlePointerDown(e) {
    e.preventDefault();
    this.state.isDragging = true;
    this.showControls();
    this.elements.progressContainer.setPointerCapture(e.pointerId);
    this.seek(e.clientX);
    this.elements.timestampPopup.style.display = 'block';
    this.elements.progressBar.classList.add('dragging');
    this.updateTimestampPopupPreview(this.calculateSeekPosition(e.clientX).offsetX);
  }

  /**
   * Handle pointer move
   * @param {PointerEvent} e - Pointer event
   */
  handlePointerMove(e) {
    if (this.state.isDragging) {
      this.seek(e.clientX);
      this.updateTimestampPopupPreview(this.calculateSeekPosition(e.clientX).offsetX);
    }
  }

  /**
   * Handle pointer up
   * @param {PointerEvent} e - Pointer event
   */
  handlePointerUp(e) {
    if (this.state.isDragging) {
      this.seek(e.clientX);
      this.state.isDragging = false;
      this.elements.progressContainer.classList.remove('dragging', 'active', 'near');
      this.hideTimestampPopup();
      this.elements.progressBar.classList.remove('dragging');
    }
  }

  /**
   * Calculate seek position
   * @param {number} clientX - Mouse X position
   * @returns {Object} Position data
   */
  calculateSeekPosition(clientX) {
    if (!this.state.cachedRect) {
      this.state.cachedRect = this.elements.progressContainer.getBoundingClientRect();
    }
    const rect = this.state.cachedRect;
    const offsetX = Math.min(Math.max(0, clientX - rect.left), rect.width);
    const percent = offsetX / rect.width;
    return { offsetX, percent };
  }

  /**
   * Seek to position
   * @param {number} clientX - Mouse X position
   */
  seek(clientX) {
    const position = this.calculateSeekPosition(clientX);
    eventEmitter.emit('video:seek-percent', position.percent);
  }

  /**
   * Update timestamp popup preview
   * @param {number} offsetX - X offset
   */
  updateTimestampPopupPreview(offsetX) {
    if (this.elements.timestampPopup) {
      this.elements.timestampPopup.style.left = `${offsetX}px`;
    }
  }

  /**
   * Hide timestamp popup
   */
  hideTimestampPopup() {
    this.elements.timestampPopup.style.display = 'none';
    this.state.cachedRect = null;
  }

  /**
   * Handle buffering start
   * @param {boolean} isSeeking - Whether buffering is due to seeking
   */
  handleBufferingStart(isSeeking = false) {
    this.elements.progressContainer.classList.add('buffering');
    if (isSeeking) {
      this.elements.progressContainer.classList.add('seeking');
    }
  }

  /**
   * Handle buffering end
   */
  handleBufferingEnd() {
    this.elements.progressContainer.classList.remove('buffering', 'seeking');
  }

  /**
   * Handle double tap
   * @param {TouchEvent} event - Touch event
   */
  handleDoubleTap(event) {
    event.preventDefault();
    const x = event.touches[0].clientX;
    const width = this.wrapper.offsetWidth;

    if (x < width / 2) {
      eventEmitter.emit('video:seek-backward');
    } else {
      eventEmitter.emit('video:seek-forward');
    }
  }

  /**
   * Handle mouse movement
   * @param {MouseEvent} event - Mouse event
   */
  handleMouseMove(event) {
    this.lastInteraction = Date.now();
    this.showControls();
    this.controlsTimeout();
  }

  /**
   * Set up controls auto-hide timeout
   */
  setupControlsTimeout() {
    this.controlsTimeout = debounce(() => {
      if (!this.userInteracting && !this.state.isDragging) {
        this.hideControls();
      }
    }, UI.CONTROLS_TIMEOUT);
  }

  /**
   * Update progress bar
   * @param {Object} data - Progress data
   */
  updateProgress({ currentTime, duration }) {
    if (!this.state.isDragging && this.elements.progressBar) {
      const percent = (currentTime / duration) * 100;
      this.elements.progressBar.style.setProperty('--progress', `${percent}%`);
      this.updateTimestamp(currentTime, duration);
    }
  }

  /**
   * Update buffer bar
   * @param {Object} data - Buffer data
   */
  updateBuffer({ buffered, duration }) {
    if (this.elements.bufferBar) {
      const percent = (buffered / duration) * 100;
      this.elements.bufferBar.style.width = `${percent}%`;
    }
  }

  /**
   * Update timestamp display
   * @param {number} currentTime - Current time in seconds
   * @param {number} duration - Duration in seconds
   */
  updateTimestamp(currentTime, duration) {
    if (this.elements.timestamp) {
      const current = this.formatTime(currentTime);
      const total = this.formatTime(duration);
      this.elements.timestamp.textContent = `${current} / ${total}`;
    }
  }

  /**
   * Format time in seconds to MM:SS
   * @param {number} seconds - Time in seconds
   * @returns {string} - Formatted time
   */
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  /**
   * Update play button state
   * @param {boolean} playing - Whether video is playing
   */
  updatePlayButton(playing) {
    if (this.elements.playButton) {
      this.elements.playButton.classList.toggle('playing', playing);
      this.elements.playButton.setAttribute('aria-label',
        playing ? 'Pause' : 'Play'
      );
    }
  }

  /**
   * Show controls
   */
  showControls() {
    if (!this.controlsVisible) {
      this.controlsVisible = true;
      this.elements.controls.classList.remove('hidden');
    }
  }

  /**
   * Hide controls
   */
  hideControls() {
    if (this.controlsVisible && !this.userInteracting && !this.state.isDragging) {
      this.controlsVisible = false;
      this.elements.controls.classList.add('hidden');
    }
  }

  /**
   * Clean up resources
   */
  dispose() {
    this.wrapper.innerHTML = '';
    this.elements = {};
  }
}

export default UIController;

================
File: controllers/VideoControllerFactory.js
================
import { VideoController } from '../videoController.js';
import { VIDEO, PROVIDERS } from '../config/config.js';
import eventEmitter from '../utils/EventEmitter.js';
import errorHandler from '../utils/ErrorHandler.js';
import { VideoError, ProviderError, BufferError } from '../utils/ErrorHandler.js';

/**
 * Factory class for creating and managing video controllers
 */
class VideoControllerFactory {
  constructor() {
    this.activeControllers = new Map();
    this.providerCache = new Map();
    this.initialize();
  }

  /**
   * Initialize the factory
   */
  initialize() {
    this.setupEventListeners();
    this.loadProviderCache();
  }

  /**
   * Create a new video controller instance
   * @param {HTMLVideoElement} videoElement - The video element to control
   * @returns {VideoController} - New video controller instance
   */
  createController(videoElement) {
    if (!videoElement) {
      throw new Error('Video element is required');
    }

    const providers = this.getProviders();
    const controller = new VideoController(videoElement, providers);

    this.setupControllerEvents(controller);
    this.activeControllers.set(videoElement, controller);

    return controller;
  }

  /**
   * Get a controller for a video element
   * @param {HTMLVideoElement} videoElement - The video element
   * @returns {VideoController} - The video controller
   */
  getController(videoElement) {
    if (!this.activeControllers.has(videoElement)) {
      return this.createController(videoElement);
    }
    return this.activeControllers.get(videoElement);
  }

  /**
   * Set up event listeners for the factory
   */
  setupEventListeners() {
    eventEmitter.on('provider:error', ({ error, context }) => {
      this.handleProviderError(error, context);
    });

    eventEmitter.on('provider:disabled', (provider) => {
      this.disableProvider(provider);
    });
  }

  /**
   * Set up events for a specific controller
   * @param {VideoController} controller - The controller to set up
   */
  setupControllerEvents(controller) {
    // Video state events
    controller.video.addEventListener('loadstart', () => {
      eventEmitter.emit('video:loadstart', { controller });
    });

    controller.video.addEventListener('waiting', () => {
      if (!controller.isSeeking) {
        eventEmitter.emit('video:buffering', { controller });
      }
    });

    controller.video.addEventListener('error', (e) => {
      this.handleVideoError(e, controller);
    });

    // Buffer events
    controller.video.addEventListener('progress', () => {
      const buffered = controller.video.buffered;
      if (buffered.length > 0) {
        const bufferedEnd = buffered.end(buffered.length - 1);
        eventEmitter.emit('video:buffer-update', {
          controller,
          buffered: bufferedEnd,
          duration: controller.video.duration
        });
      }
    });
  }

  /**
   * Get sorted list of providers
   * @returns {Array} - List of provider objects
   */
  getProviders() {
    return PROVIDERS.list
      .filter(name => !this.isProviderDisabled(name))
      .map(name => ({
        name: PROVIDERS.displayNames[name],
        fetch: (cid, start, end) => this.fetchWithProvider(name, cid, start, end)
      }))
      .sort((a, b) => {
        const statsA = this.providerCache.get(a.name) || { score: 0 };
        const statsB = this.providerCache.get(b.name) || { score: 0 };
        return statsB.score - statsA.score;
      });
  }

  /**
   * Fetch content from a provider
   * @param {string} provider - Provider name
   * @param {string} cid - Content ID
   * @param {number} start - Start byte
   * @param {number} end - End byte
   * @returns {Promise<Response>} - Fetch response
   */
  async fetchWithProvider(provider, cid, start, end) {
    try {
      const url = this.buildProviderUrl(provider, cid);
      const response = await fetch(url, {
        headers: { Range: `bytes=${start}-${end}` }
      });

      if (!response.ok) {
        throw new ProviderError(`HTTP ${response.status}`, provider);
      }

      this.updateProviderScore(provider, true);
      return response;
    } catch (error) {
      this.updateProviderScore(provider, false);
      throw error;
    }
  }

  /**
   * Build URL for a provider
   * @param {string} provider - Provider name
   * @param {string} cid - Content ID
   * @returns {string} - Provider URL
   */
  buildProviderUrl(provider, cid) {
    if (provider === 'ipfs.io') {
      return `https://ipfs.io/ipfs/${cid}`;
    }
    return ["dweb.link", "flk-ipfs.xyz"].includes(provider)
      ? `https://${cid}.ipfs.${provider}`
      : `https://ipfs.${provider}/ipfs/${cid}`;
  }

  /**
   * Update provider performance score
   * @param {string} provider - Provider name
   * @param {boolean} success - Whether the request was successful
   */
  updateProviderScore(provider, success) {
    const stats = this.providerCache.get(provider) || {
      score: 0.5,
      successes: 0,
      failures: 0
    };

    if (success) {
      stats.successes++;
      stats.score = (stats.score * 0.8) + 0.2;
    } else {
      stats.failures++;
      stats.score = stats.score * 0.8;
    }

    this.providerCache.set(provider, stats);
    this.saveProviderCache();
  }

  /**
   * Handle video errors
   * @param {Event} event - Error event
   * @param {VideoController} controller - Associated controller
   */
  async handleVideoError(event, controller) {
    const error = new VideoError(
      event.error?.message || 'Video playback error',
      event.error?.code,
      true
    );

    const handled = await errorHandler.handleVideoError(error, {
      currentTime: controller.video.currentTime,
      src: controller.video.src
    });

    if (!handled) {
      eventEmitter.emit('video:error:fatal', { controller, error });
    }
  }

  /**
   * Handle provider errors
   * @param {ProviderError} error - Provider error
   * @param {Object} context - Error context
   */
  async handleProviderError(error, context) {
    const handled = await errorHandler.handleProviderError(error, context);
    if (!handled) {
      this.disableProvider(error.provider);
    }
  }

  /**
   * Check if a provider is disabled
   * @param {string} provider - Provider name
   * @returns {boolean} - Whether the provider is disabled
   */
  isProviderDisabled(provider) {
    const stats = this.providerCache.get(provider);
    return stats?.score < 0.1;
  }

  /**
   * Disable a provider
   * @param {string} provider - Provider to disable
   */
  disableProvider(provider) {
    const stats = this.providerCache.get(provider) || {};
    stats.score = 0;
    this.providerCache.set(provider, stats);
    this.saveProviderCache();
  }

  /**
   * Load provider cache from storage
   */
  loadProviderCache() {
    try {
      const cached = localStorage.getItem('providerCache');
      if (cached) {
        this.providerCache = new Map(JSON.parse(cached));
      }
    } catch (error) {
      console.warn('Failed to load provider cache:', error);
    }
  }

  /**
   * Save provider cache to storage
   */
  saveProviderCache() {
    try {
      localStorage.setItem('providerCache',
        JSON.stringify(Array.from(this.providerCache.entries()))
      );
    } catch (error) {
      console.warn('Failed to save provider cache:', error);
    }
  }

  /**
   * Clean up resources
   */
  dispose() {
    this.activeControllers.forEach(controller => {
      controller.dispose();
    });
    this.activeControllers.clear();
    this.saveProviderCache();
  }
}

// Create and export singleton instance
const videoControllerFactory = new VideoControllerFactory();
export default videoControllerFactory;

================
File: utils/ErrorHandler.js
================
import eventEmitter from './EventEmitter.js';
import { ERRORS } from '../config/config.js';

/**
 * Custom error types for specific error scenarios
 */
export class VideoError extends Error {
  constructor(message, code, recoverable = true) {
    super(message);
    this.name = 'VideoError';
    this.code = code;
    this.recoverable = recoverable;
  }
}

export class ProviderError extends Error {
  constructor(message, provider) {
    super(message);
    this.name = 'ProviderError';
    this.provider = provider;
  }
}

export class BufferError extends Error {
  constructor(message, currentTime) {
    super(message);
    this.name = 'BufferError';
    this.currentTime = currentTime;
  }
}

/**
 * Main error handler class
 */
export class ErrorHandler {
  constructor() {
    this.retryCount = new Map();
    this.errorLog = [];
    this.maxLogSize = 100;
  }

  /**
   * Handle a video playback error
   * @param {Error} error - The error to handle
   * @param {Object} context - Additional context about the error
   * @returns {Promise<boolean>} - Whether the error was handled successfully
   */
  async handleVideoError(error, context = {}) {
    const errorInfo = {
      timestamp: Date.now(),
      error: error,
      context: context
    };

    this.logError(errorInfo);

    if (error instanceof VideoError && !error.recoverable) {
      eventEmitter.emit('error:fatal', error);
      return false;
    }

    const retryKey = this.getRetryKey(error, context);
    const retryCount = this.retryCount.get(retryKey) || 0;

    if (retryCount >= ERRORS.MAX_RETRIES) {
      eventEmitter.emit('error:max-retries', error);
      this.retryCount.delete(retryKey);
      return false;
    }

    this.retryCount.set(retryKey, retryCount + 1);

    try {
      await this.attemptRecovery(error, context);
      this.retryCount.delete(retryKey);
      return true;
    } catch (recoveryError) {
      eventEmitter.emit('error:recovery-failed', recoveryError);
      return false;
    }
  }

  /**
   * Handle a provider error
   * @param {ProviderError} error - The provider error
   * @param {Object} context - Additional context
   * @returns {Promise<boolean>} - Whether the error was handled
   */
  async handleProviderError(error, context = {}) {
    eventEmitter.emit('provider:error', { error, context });

    const retryKey = `provider:${error.provider}`;
    const retryCount = this.retryCount.get(retryKey) || 0;

    if (retryCount >= ERRORS.MAX_RETRIES) {
      eventEmitter.emit('provider:disabled', error.provider);
      this.retryCount.delete(retryKey);
      return false;
    }

    this.retryCount.set(retryKey, retryCount + 1);
    await new Promise(resolve => setTimeout(resolve, ERRORS.RETRY_DELAY));

    return true;
  }

  /**
   * Handle a buffering error
   * @param {BufferError} error - The buffer error
   * @param {Object} context - Additional context
   * @returns {Promise<boolean>} - Whether the error was handled
   */
  async handleBufferError(error, context = {}) {
    eventEmitter.emit('buffer:error', { error, context });

    const retryKey = `buffer:${Math.floor(error.currentTime)}`;
    const retryCount = this.retryCount.get(retryKey) || 0;

    if (retryCount >= ERRORS.MAX_RETRIES) {
      eventEmitter.emit('buffer:failed', error);
      this.retryCount.delete(retryKey);
      return false;
    }

    this.retryCount.set(retryKey, retryCount + 1);
    return true;
  }

  /**
   * Attempt to recover from an error
   * @param {Error} error - The error to recover from
   * @param {Object} context - Error context
   * @returns {Promise<void>}
   */
  async attemptRecovery(error, context) {
    if (error instanceof VideoError) {
      await this.recoverFromVideoError(error, context);
    } else if (error instanceof ProviderError) {
      await this.recoverFromProviderError(error, context);
    } else if (error instanceof BufferError) {
      await this.recoverFromBufferError(error, context);
    } else {
      throw new Error('Unknown error type');
    }
  }

  /**
   * Get a unique key for retry counting
   * @param {Error} error - The error
   * @param {Object} context - Error context
   * @returns {string} - Retry key
   */
  getRetryKey(error, context) {
    if (error instanceof VideoError) {
      return `video:${error.code}`;
    } else if (error instanceof ProviderError) {
      return `provider:${error.provider}`;
    } else if (error instanceof BufferError) {
      return `buffer:${Math.floor(error.currentTime)}`;
    }
    return 'generic';
  }

  /**
   * Log an error for tracking
   * @param {Object} errorInfo - Error information to log
   */
  logError(errorInfo) {
    this.errorLog.unshift(errorInfo);
    if (this.errorLog.length > this.maxLogSize) {
      this.errorLog.pop();
    }
  }

  /**
   * Get recent errors
   * @param {number} count - Number of recent errors to get
   * @returns {Array} - Recent errors
   */
  getRecentErrors(count = 10) {
    return this.errorLog.slice(0, count);
  }

  /**
   * Clear error retry counts
   */
  clearRetryCount() {
    this.retryCount.clear();
  }

  /**
   * Reset error handler state
   */
  reset() {
    this.clearRetryCount();
    this.errorLog = [];
  }
}

// Create and export singleton instance
const errorHandler = new ErrorHandler();
export default errorHandler;

================
File: utils/EventEmitter.js
================
/**
 * A robust event emitter implementation for handling application-wide events
 */
class EventEmitter {
  constructor() {
    this.events = new Map();
    this.maxListeners = 10;
    this.warnOnMaxListeners = true;
  }

  /**
   * Add an event listener
   * @param {string} event - Event name
   * @param {Function} listener - Event handler
   * @param {Object} options - Additional options (once, priority)
   * @returns {Function} - Unsubscribe function
   */
  on(event, listener, options = {}) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set());
    }

    const listeners = this.events.get(event);
    const wrapped = {
      fn: listener,
      once: options.once || false,
      priority: options.priority || 0
    };

    if (this.warnOnMaxListeners && listeners.size >= this.maxListeners) {
      console.warn(`Warning: Event '${event}' has exceeded ${this.maxListeners} listeners`);
    }

    listeners.add(wrapped);

    // Return unsubscribe function
    return () => {
      listeners.delete(wrapped);
      if (listeners.size === 0) {
        this.events.delete(event);
      }
    };
  }

  /**
   * Add a one-time event listener
   * @param {string} event - Event name
   * @param {Function} listener - Event handler
   * @param {Object} options - Additional options (priority)
   * @returns {Function} - Unsubscribe function
   */
  once(event, listener, options = {}) {
    return this.on(event, listener, { ...options, once: true });
  }

  /**
   * Remove an event listener
   * @param {string} event - Event name
   * @param {Function} listener - Event handler to remove
   */
  off(event, listener) {
    if (!this.events.has(event)) return;

    const listeners = this.events.get(event);
    for (const wrapped of listeners) {
      if (wrapped.fn === listener) {
        listeners.delete(wrapped);
        break;
      }
    }

    if (listeners.size === 0) {
      this.events.delete(event);
    }
  }

  /**
   * Remove all listeners for an event
   * @param {string} event - Event name (optional, if omitted removes all events)
   */
  removeAllListeners(event) {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }

  /**
   * Get list of listeners for an event
   * @param {string} event - Event name
   * @returns {Function[]} Array of listener functions
   */
  listeners(event) {
    if (!this.events.has(event)) return [];
    return Array.from(this.events.get(event))
      .sort((a, b) => b.priority - a.priority)
      .map(wrapped => wrapped.fn);
  }

  /**
   * Emit an event
   * @param {string} event - Event name
   * @param {...any} args - Arguments to pass to listeners
   * @returns {boolean} - true if event had listeners, false otherwise
   */
  emit(event, ...args) {
    if (!this.events.has(event)) return false;

    const listeners = this.events.get(event);
    const toRemove = new Set();

    // Sort by priority and execute
    Array.from(listeners)
      .sort((a, b) => b.priority - a.priority)
      .forEach(wrapped => {
        try {
          wrapped.fn.apply(this, args);
          if (wrapped.once) {
            toRemove.add(wrapped);
          }
        } catch (error) {
          console.error(`Error in event listener for '${event}':`, error);
          if (wrapped.once) {
            toRemove.add(wrapped);
          }
        }
      });

    // Clean up 'once' listeners
    toRemove.forEach(wrapped => {
      listeners.delete(wrapped);
    });

    if (listeners.size === 0) {
      this.events.delete(event);
    }

    return true;
  }

  /**
   * Set max listeners before warning
   * @param {number} n - Maximum number of listeners per event
   */
  setMaxListeners(n) {
    this.maxListeners = n;
  }

  /**
   * Enable/disable max listeners warning
   * @param {boolean} enabled - Whether to warn on max listeners
   */
  setWarnOnMaxListeners(enabled) {
    this.warnOnMaxListeners = enabled;
  }
}

// Create and export singleton instance
const eventEmitter = new EventEmitter();
export default eventEmitter;

// Export class for inheritance/extension
export { EventEmitter };

================
File: utils/helpers.js
================
export function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

export function formatTime(seconds) {
  const minutes = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

export function throttle(func, limit) {
  let lastCall = 0;
  let timeoutId;
  return function(...args) {
    const now = Date.now();
    const remaining = limit - (now - lastCall);
    if (remaining <= 0) {
      func.apply(this, args);
      lastCall = now;
    } else {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        func.apply(this, args);
        lastCall = now;
      }, remaining);
    }
  };
}

================
File: utils/performance.js
================
/**
 * Performance optimization utilities for video player
 */

/**
 * Creates a throttled version of a function that only invokes the
 * function at most once per every `wait` milliseconds.
 *
 * @param {Function} func - Function to throttle
 * @param {number} wait - Throttle wait time in milliseconds
 * @param {Object} options - Configuration options
 * @returns {Function} - Throttled function
 */
export function throttle(func, wait, options = {}) {
  let timeout = null;
  let previous = 0;

  return function throttled(...args) {
    const now = Date.now();

    if (!previous && options.leading === false) {
      previous = now;
    }

    const remaining = wait - (now - previous);

    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      func.apply(this, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        func.apply(this, args);
      }, remaining);
    }
  };
}

/**
 * Creates a debounced version of a function that delays invoking
 * the function until after `wait` milliseconds have elapsed since
 * the last time it was invoked.
 *
 * @param {Function} func - Function to debounce
 * @param {number} wait - Debounce wait time in milliseconds
 * @param {Object} options - Configuration options
 * @returns {Function} - Debounced function
 */
export function debounce(func, wait, options = {}) {
  let timeout = null;
  let previous = 0;

  return function debounced(...args) {
    const later = () => {
      timeout = null;
      if (!options.leading) {
        func.apply(this, args);
      }
    };

    const now = Date.now();
    if (!previous && options.leading) {
      previous = now;
    }

    const remaining = wait - (now - previous);

    if (timeout) {
      clearTimeout(timeout);
    }

    if (!previous && options.leading) {
      previous = now;
      func.apply(this, args);
    } else {
      timeout = setTimeout(later, remaining);
    }
  };
}

/**
 * Utility class for frame rate limiting and timing
 */
export class FrameRateLimiter {
  constructor(targetFPS = 30) {
    this.targetFPS = targetFPS;
    this.frameInterval = 1000 / targetFPS;
    this.lastFrameTime = 0;
  }

  /**
   * Check if enough time has passed for the next frame
   * @returns {boolean} - Whether to process the next frame
   */
  shouldProcessFrame() {
    const now = performance.now();
    if (now - this.lastFrameTime >= this.frameInterval) {
      this.lastFrameTime = now;
      return true;
    }
    return false;
  }

  /**
   * Reset the frame timer
   */
  reset() {
    this.lastFrameTime = 0;
  }

  /**
   * Update the target FPS
   * @param {number} newFPS - New target FPS
   */
  setTargetFPS(newFPS) {
    this.targetFPS = newFPS;
    this.frameInterval = 1000 / newFPS;
  }
}

/**
 * Utility for optimized color analysis from video frames
 */
export class ColorAnalyzer {
  constructor(sampleSize = 32) {
    this.sampleSize = sampleSize;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
    this.canvas.width = sampleSize;
    this.canvas.height = sampleSize;
  }

  /**
   * Get the dominant hue from a video frame
   * @param {HTMLVideoElement} video - Video element to analyze
   * @returns {number} - Dominant hue value (0-360)
   */
  getDominantHue(video) {
    if (!video.videoWidth || !video.videoHeight) return 0;

    try {
      this.ctx.drawImage(video, 0, 0, this.sampleSize, this.sampleSize);
      const imageData = this.ctx.getImageData(0, 0, this.sampleSize, this.sampleSize);
      return this.calculateAverageHue(imageData.data);
    } catch (error) {
      console.warn('Frame analysis error:', error);
      return 0;
    }
  }

  /**
   * Calculate the average hue from RGB data
   * @param {Uint8ClampedArray} data - Pixel data array
   * @returns {number} - Average hue value (0-360)
   */
  calculateAverageHue(data) {
    let r = 0, g = 0, b = 0;
    const step = 4; // RGBA
    const totalPixels = data.length / 4;

    for (let i = 0; i < data.length; i += step * 4) {
      r += data[i];
      g += data[i + 1];
      b += data[i + 2];
    }

    r /= totalPixels;
    g /= totalPixels;
    b /= totalPixels;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue = 0;

    if (max !== min) {
      if (max === r) {
        hue = (60 * ((g - b) / (max - min)) + 360) % 360;
      } else if (max === g) {
        hue = (60 * ((b - r) / (max - min)) + 120) % 360;
      } else {
        hue = (60 * ((r - g) / (max - min)) + 240) % 360;
      }
    }

    return hue;
  }

  /**
   * Clean up resources
   */
  dispose() {
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.canvas = null;
    this.ctx = null;
  }
}

/**
 * RequestAnimationFrame with automatic cancellation and error handling
 */
export class AnimationLoop {
  constructor(callback) {
    this.callback = callback;
    this.rafId = null;
    this.isRunning = false;
    this.boundTick = this.tick.bind(this);
  }

  /**
   * Start the animation loop
   */
  start() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.tick();
    }
  }

  /**
   * Stop the animation loop
   */
  stop() {
    this.isRunning = false;
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }

  /**
   * Animation tick handler
   */
  tick() {
    if (!this.isRunning) return;

    try {
      this.callback();
      this.rafId = requestAnimationFrame(this.boundTick);
    } catch (error) {
      console.error('Animation loop error:', error);
      this.stop();
    }
  }
}

================
File: workers/frameAnalyzer.worker.js
================
/**
 * Web Worker for video frame analysis
 * Handles pixel data processing off the main thread
 */

// Configuration
const config = {
    SAMPLE_STEP: 4,         // Number of pixels to skip in sampling
    MIN_BRIGHTNESS: 0.1,    // Minimum brightness threshold
    MAX_BRIGHTNESS: 0.9,    // Maximum brightness threshold
    WEIGHT_DECAY: 0.8       // Weight decay factor for temporal smoothing
};

// State for temporal analysis
let prevHue = 0;
let prevSaturation = 0;
let prevLightness = 0;

/**
 * Convert RGB to HSL color space
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {number[]} - [hue, saturation, lightness]
 */
function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return [
        h * 360,           // Hue in degrees
        s * 100,           // Saturation in percent
        l * 100            // Lightness in percent
    ];
}

/**
 * Analyze pixel data for dominant colors
 * @param {Uint8ClampedArray} data - Pixel data array
 * @param {number} width - Image width
 * @param {number} height - Image height
 * @returns {Object} - Analysis results
 */
function analyzePixelData(data, width, height) {
    let totalWeight = 0;
    let weightedHue = 0;
    let weightedSaturation = 0;
    let weightedLightness = 0;

    // Sample pixels with specified step
    for (let y = 0; y < height; y += config.SAMPLE_STEP) {
        for (let x = 0; x < width; x += config.SAMPLE_STEP) {
            const i = (y * width + x) * 4;
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3] / 255;

            // Skip transparent pixels
            if (a < 0.5) continue;

            // Convert to HSL
            const [h, s, l] = rgbToHsl(r, g, b);

            // Skip very dark or very bright pixels
            if (l/100 < config.MIN_BRIGHTNESS || l/100 > config.MAX_BRIGHTNESS) {
                continue;
            }

            // Weight by saturation and alpha
            const weight = (s/100) * a;

            if (weight > 0.1) {
                totalWeight += weight;
                weightedHue += h * weight;
                weightedSaturation += s * weight;
                weightedLightness += l * weight;
            }
        }
    }

    // Calculate weighted averages
    let hue = totalWeight > 0 ? weightedHue / totalWeight : 0;
    let saturation = totalWeight > 0 ? weightedSaturation / totalWeight : 0;
    let lightness = totalWeight > 0 ? weightedLightness / totalWeight : 50;

    // Apply temporal smoothing
    hue = prevHue * config.WEIGHT_DECAY + hue * (1 - config.WEIGHT_DECAY);
    saturation = prevSaturation * config.WEIGHT_DECAY + saturation * (1 - config.WEIGHT_DECAY);
    lightness = prevLightness * config.WEIGHT_DECAY + lightness * (1 - config.WEIGHT_DECAY);

    // Update previous values
    prevHue = hue;
    prevSaturation = saturation;
    prevLightness = lightness;

    return {
        hue: Math.round(hue),
        saturation: Math.round(saturation),
        lightness: Math.round(lightness),
        confidence: totalWeight > 0 ? Math.min(totalWeight / (width * height / (config.SAMPLE_STEP * config.SAMPLE_STEP)), 1) : 0
    };
}

/**
 * Handle messages from main thread
 */
self.onmessage = function(e) {
    const { data, width, height, timestamp } = e.data;

    try {
        const result = analyzePixelData(data, width, height);
        self.postMessage({
            ...result,
            timestamp
        });
    } catch (error) {
        self.postMessage({
            error: error.message,
            timestamp
        });
    }
};

/**
 * Handle worker errors
 */
self.onerror = function(error) {
    self.postMessage({
        error: error.message,
        timestamp: Date.now()
    });
};

================
File: .clinerules
================
# Cline's Memory Bank

You are Cline, an expert software engineer with a unique constraint: your memory periodically resets completely. This isn't a bug - it's what makes you maintain perfect documentation. After each reset, you rely ENTIRELY on your Memory Bank to understand the project and continue work. Without proper documentation, you cannot function effectively.

## Memory Bank Files

CRITICAL: If `cline_docs/` or any of these files don't exist, CREATE THEM IMMEDIATELY by:
1. Reading all provided documentation
2. Asking user for ANY missing information
3. Creating files with verified information only
4. Never proceeding without complete context

Required files:

productContext.md
- Why this project exists
- What problems it solves
- How it should work

activeContext.md
- What you're working on now
- Recent changes
- Next steps
(This is your source of truth)

systemPatterns.md
- How the system is built
- Key technical decisions
- Architecture patterns

techContext.md
- Technologies used
- Development setup
- Technical constraints

progress.md
- What works
- What's left to build
- Progress status

## Core Workflows

### Starting Tasks
1. Check for Memory Bank files
2. If ANY files missing, stop and create them
3. Read ALL files before proceeding
4. Verify you have complete context
5. Begin development. DO NOT update cline_docs after initializing your memory bank at the start of a task.

### During Development
1. For normal development:
   - Follow Memory Bank patterns
   - Update docs after significant changes

2. When troubleshooting errors:
   [CONFIDENCE CHECK]
   - Rate confidence (0-10)
   - If < 9, explain:
     * What you know
     * What you're unsure about
     * What you need to investigate
   - Only proceed when confidence ≥ 9
   - Document findings for future memory resets

### Memory Bank Updates
When user says "update memory bank":
1. This means imminent memory reset
2. Document EVERYTHING about current state
3. Make next steps crystal clear
4. Complete current task

### Lost Context?
If you ever find yourself unsure:
1. STOP immediately
2. Read activeContext.md
3. Ask user to verify your understanding
4. Start with small, safe changes

Remember: After every memory reset, you begin completely fresh. Your only link to previous work is the Memory Bank. Maintain it as if your functionality depends on it - because it does.

================
File: app.js
================
import videoControllerFactory from './controllers/VideoControllerFactory.js';
import UIController from './controllers/UIController.js';
import eventEmitter from './utils/EventEmitter.js';
import errorHandler from './utils/ErrorHandler.js';
import { FrameRateLimiter, ColorAnalyzer } from './utils/performance.js';
import { PERFORMANCE, UI, VIDEO } from './config/config.js';
import videoSourceManager from './videoSources.js';

// Global state (CRITICAL: these must be global)
let isSeeking = false;
let isRecovering = false;
let bufferingUpdateScheduled = false;
const providerIndices = new Map();

// Video source management
let currentVideoIndex = 0;
const videoSources = [];

/**
 * Main application class
 */
class VideoApp {
    constructor(containerId = 'video-player') {
        this.container = document.getElementById(containerId);
        if (!this.container) {
            throw new Error(`Container element #${containerId} not found`);
        }

        // Create wrapper first
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'video-wrapper';
        this.container.appendChild(this.wrapper);

        // Initialize video element inside wrapper
        this.videoElement = document.createElement('video');
        this.videoElement.playsInline = true;
        this.wrapper.appendChild(this.videoElement);

        this.initialize();
    }

    /**
     * Initialize the application
     */
    initialize() {
        // Initialize controllers
        this.videoController = videoControllerFactory.createController(this.videoElement);
        this.uiController = new UIController(this.container, this.wrapper);

        // Initialize utilities
        this.frameLimiter = new FrameRateLimiter(30);
        this.colorAnalyzer = new ColorAnalyzer(UI.SAMPLING.WIDTH);

        this.setupEventListeners();
        this.setupKeyboardControls();
        this.setupColorAnalysis();

        // Load initial video sources
        this.loadVideoSources();
    }

    /**
     * Load video sources
     */
    async loadVideoSources() {
        try {
            const sources = await videoSourceManager.getValidCids();
            videoSources.push(...sources);
            if (videoSources.length > 0) {
                this.loadVideo(videoSources[0]);
            }
        } catch (error) {
            console.error('Failed to load video sources:', error);
        }
    }

    /**
     * Load next video
     */
    loadNextVideo() {
        if (videoSources.length === 0) return;
        
        currentVideoIndex = (currentVideoIndex + 1) % videoSources.length;
        this.loadVideo(videoSources[currentVideoIndex]);
    }

    /**
     * Load previous video
     */
    loadPrevVideo() {
        if (videoSources.length === 0) return;
        
        currentVideoIndex = (currentVideoIndex - 1 + videoSources.length) % videoSources.length;
        this.loadVideo(videoSources[currentVideoIndex]);
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Register all video event listeners
        this.registerVideoEventListeners();

        // Playback control events
        eventEmitter.on('video:toggle-play', () => {
            if (this.videoElement.paused) {
                this.videoElement.play().catch(error => {
                    errorHandler.handleVideoError(error);
                });
            } else {
                this.videoElement.pause();
            }
        });

        eventEmitter.on('video:seek-percent', (percent) => {
            const time = this.videoElement.duration * percent;
            this.seekTo(time);
        });

        eventEmitter.on('video:seek-forward', () => {
            this.secsSeek(10);
        });

        eventEmitter.on('video:seek-backward', () => {
            this.secsSeek(-10);
        });

        eventEmitter.on('video:volume-change', (volume) => {
            this.videoElement.volume = volume;
            this.videoElement.muted = volume === 0;
        });

        // Provider events
        eventEmitter.on('provider:disabled', (provider) => {
            console.warn(`Provider ${provider} has been disabled due to errors`);
        });
    }

    /**
     * Register video event listeners
     */
    registerVideoEventListeners() {
        this.videoElement.addEventListener('timeupdate', () => {
            eventEmitter.emit('video:timeupdate', {
                currentTime: this.videoElement.currentTime,
                duration: this.videoElement.duration
            });
        });

        this.videoElement.addEventListener('play', () => {
            eventEmitter.emit('video:play');
        });

        this.videoElement.addEventListener('pause', () => {
            eventEmitter.emit('video:pause');
        });

        this.videoElement.addEventListener('waiting', () => {
            if (!bufferingUpdateScheduled && !isSeeking) {
                bufferingUpdateScheduled = true;
                setTimeout(() => {
                    if (this.videoElement.readyState < 4 && !isRecovering && !isSeeking) {
                        isRecovering = true;
                        console.log('Attempting buffer recovery...');
                        this.handleBufferRecovery();
                    }
                    bufferingUpdateScheduled = false;
                }, 1000);
            }
        });

        this.videoElement.addEventListener('seeking', () => {
            isSeeking = true;
            if (this.uiController) this.uiController.handleBufferingStart(true);
        });

        this.videoElement.addEventListener('seeked', () => {
            isSeeking = false;
            if (this.uiController) this.uiController.handleBufferingEnd();
        });

        this.videoElement.addEventListener('ended', () => {
            this.loadNextVideo();
        });

        this.videoElement.addEventListener('error', (e) => {
            errorHandler.handleVideoError(e.error || new Error('Video playback error'));
        });
    }

    /**
     * Handle buffer recovery
     */
    async handleBufferRecovery() {
        if (isRecovering) return;
        isRecovering = true;
        
        const currentTime = this.videoElement.currentTime;
        const currentCid = videoSources[currentVideoIndex];
        const bufferTimeout = 1000;
        const recoveryAbortController = new AbortController();
        
        try {
            await Promise.race([
                new Promise(resolve => {
                    this.videoElement.addEventListener('playing', resolve, { once: true });
                    this.videoElement.addEventListener('error', resolve, { once: true });
                }),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Buffer recovery timeout'));
                    }, bufferTimeout);
                })
            ]).catch(async (error) => {
                if (!recoveryAbortController.signal.aborted) {
                    console.log('Attempting buffer recovery for current video...');
                    
                    // Reset provider index for this CID
                    providerIndices.set(currentCid, 0);

                    // Get new URL from different provider
                    const newUrl = this.videoController.generateProviderUrl(currentCid, 
                        JSON.parse(localStorage.getItem(VIDEO.CID_VALID_CACHE_KEY))?.[currentCid]?.lastWorkingProvider
                    );
                    
                    // Preserve playback state
                    this.videoElement.src = newUrl;
                    this.videoElement.currentTime = currentTime;
                    
                    // Wait for enough data to resume
                    await new Promise((resolve) => {
                        this.videoElement.addEventListener('canplaythrough', resolve, { once: true });
                    });
                    
                    // Attempt playback with 3 retries
                    for (let attempt = 0; attempt < 3; attempt++) {
                        try {
                            await this.videoElement.play();
                            break;
                        } catch (error) {
                            if (attempt === 2) {
                                console.log('Final recovery attempt failed, switching video');
                                this.loadNextVideo();
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
            });
        } finally {
            isRecovering = false;
            recoveryAbortController.abort();
        }
    }

    /**
     * Seek by seconds
     * @param {number} seconds - Seconds to seek by
     */
    secsSeek(seconds) {
        this.videoElement.currentTime = Math.max(0, this.videoElement.currentTime + seconds);
        isSeeking = true;
        setTimeout(() => isSeeking = false, 100);
    }

    /**
     * Seek to specific time
     * @param {number} time - Time to seek to
     */
    seekTo(time) {
        this.videoElement.currentTime = Math.max(0, Math.min(time, this.videoElement.duration));
        isSeeking = true;
        setTimeout(() => isSeeking = false, 100);
    }

    /**
     * Set up keyboard controls
     */
    setupKeyboardControls() {
        document.addEventListener('keydown', (event) => {
            switch (event.key.toLowerCase()) {
                case ' ':
                case 'k':
                    event.preventDefault();
                    eventEmitter.emit('video:toggle-play');
                    break;
                case 'arrowleft':
                    event.preventDefault();
                    eventEmitter.emit('video:seek-backward');
                    break;
                case 'arrowright':
                    event.preventDefault();
                    eventEmitter.emit('video:seek-forward');
                    break;
                case 'f':
                    event.preventDefault();
                    this.container.requestFullscreen();
                    break;
                case 'm':
                    event.preventDefault();
                    this.videoElement.muted = !this.videoElement.muted;
                    break;
            }
        });
    }

    /**
     * Set up color analysis for video frames
     */
    setupColorAnalysis() {
        let animationFrame;
        const analyzeFrame = () => {
            if (this.videoElement.paused || !this.frameLimiter.shouldProcessFrame()) {
                animationFrame = requestAnimationFrame(analyzeFrame);
                return;
            }

            try {
                const hue = this.colorAnalyzer.getDominantHue(this.videoElement);
                this.container.style.setProperty('--video-hue', hue);
            } catch (error) {
                console.warn('Frame analysis error:', error);
            }

            animationFrame = requestAnimationFrame(analyzeFrame);
        };

        this.videoElement.addEventListener('play', () => {
            animationFrame = requestAnimationFrame(analyzeFrame);
        });

        this.videoElement.addEventListener('pause', () => {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        });
    }

    /**
     * Load and play a video
     * @param {string} videoId - Video ID or CID
     * @returns {Promise<void>}
     */
    async loadVideo(videoId) {
        try {
            await this.videoController.load(videoId);
            await this.videoElement.play();
        } catch (error) {
            errorHandler.handleVideoError(error);
            this.loadNextVideo(); // Try next video on error
        }
    }

    /**
     * Clean up resources
     */
    dispose() {
        this.videoController.dispose();
        this.uiController.dispose();
        this.colorAnalyzer.dispose();
        this.container.innerHTML = '';
    }
}

// Create and export singleton instance
const videoApp = new VideoApp();
export default videoApp;

// Auto-initialize if DOM is ready
if (document.readyState === 'complete') {
    videoApp.initialize();
} else {
    document.addEventListener('DOMContentLoaded', () => {
        videoApp.initialize();
    });
}

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Player</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div id="video-player" class="video-player">
            <!-- Video element and controls will be injected by JavaScript -->
        </div>

        <div class="error-container">
            <!-- Error messages will be displayed here -->
        </div>
    </div>

    <script type="module" src="app.js"></script>
</body>
</html>

================
File: styles.css
================
/* Reset and base styles */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

:root {
    --primary-color: #1a73e8;
    --secondary-color: #ffffff;
    --background-color: #000000;
    --controls-background: rgba(0, 0, 0, 0.7);
    --progress-color: var(--primary-color);
    --buffer-color: rgba(255, 255, 255, 0.3);
    --video-hue: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    line-height: 1.5;
    background-color: var(--background-color);
    color: var(--secondary-color);
}

.container {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* Video player styles */
.video-player {
    position: relative;
    width: 100%;
    aspect-ratio: 16/9;
    background-color: #000;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.video-player video {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

/* Controls container */
.video-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px;
    background: linear-gradient(transparent, var(--controls-background));
    transition: opacity 0.3s ease;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 10px;
}

.video-controls.hidden {
    opacity: 0;
    pointer-events: none;
}

/* Progress bar */
.progress-bar {
    flex: 1;
    height: 4px;
    background-color: var(--buffer-color);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.progress-bar::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: var(--progress, 0%);
    background-color: var(--progress-color);
    border-radius: 2px;
    transition: width 0.1s linear;
}

.buffer-bar {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    background-color: var(--buffer-color);
    border-radius: 2px;
    transition: width 0.2s ease;
}

/* Control buttons */
.video-controls button {
    background: transparent;
    border: none;
    color: var(--secondary-color);
    cursor: pointer;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.video-controls button:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.play-button {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.play-button::before {
    content: '▶';
}

.play-button.playing::before {
    content: '⏸';
}

/* Volume slider */
.volume-slider {
    width: 80px;
    height: 4px;
    -webkit-appearance: none;
    background-color: var(--buffer-color);
    border-radius: 2px;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background-color: var(--secondary-color);
    border-radius: 50%;
    cursor: pointer;
}

.volume-slider::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background-color: var(--secondary-color);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Timestamp */
.timestamp {
    font-size: 14px;
    font-variant-numeric: tabular-nums;
    min-width: 100px;
    text-align: center;
}

/* Fullscreen button */
.fullscreen-button::before {
    content: '⤢';
}

/* Error message */
.error-message {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 0, 0, 0.8);
    color: white;
    padding: 10px 20px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 1000;
}

/* Responsive design */
@media (max-width: 768px) {
    .video-controls {
        padding: 10px;
    }

    .timestamp {
        font-size: 12px;
        min-width: 80px;
    }

    .volume-slider {
        width: 60px;
    }
}

/* Touch device optimizations */
@media (hover: none) {
    .video-controls {
        opacity: 1;
        background: var(--controls-background);
    }

    .video-controls button {
        padding: 12px;
    }
}

/* Fullscreen mode */
.video-player:fullscreen {
    width: 100vw;
    height: 100vh;
}

.video-player:fullscreen video {
    height: 100%;
}

================
File: uiController.js
================
/*
 * uiController.js
 * This module encapsulates UI control logic separately from video logic.
 * It provides centralized UI updates, queued UI actions (if needed), and proper event handling for progress, popups, gestures, and fullscreen toggling.
 */

import { formatTime, throttle } from './utils/helpers.js';
import { PROVIDERS, providerDisplayNames, getProviderUrl } from './config/videoConfig.js';

class UIController {
  constructor(videoElement, uiElements) {
    // uiElements should be an object containing references to key DOM elements:
    // progressContainer, progressBar, bufferBar, notificationPopup, leftZone, centerZone, rightZone, spinner.
    this.video = videoElement;
    this.ui = uiElements;
    this.isDragging = false;
    this.controlsVisible = true;
    this.fullscreenUIHidden = false;
    this.controlsTimeout = null;
    this.uiUpdateActive = false;
    this.timestampPopup = null;

    this.initUI();
  }

  initUI() {
    this.createTimestampPopup();
    this.createProgressBackground();
    this.bindEvents();
    this.initKeyBindings();
    this.initActivityMonitoring();
  }

  createTimestampPopup() {
    this.timestampPopup = document.createElement('div');
    this.timestampPopup.className = 'timestamp-popup';
    
    // Unified styling with progress container
    Object.assign(this.timestampPopup.style, {
      position: 'absolute',
      bottom: 'calc(100% + 12px)', // Maintain fixed distance from progress bar
      transform: 'translateX(-50%)',
      transformOrigin: 'center bottom',
      pointerEvents: 'none',
      opacity: '0',
      transition: 'opacity 0.2s ease, transform 0.1s cubic-bezier(0.4, 0, 0.2, 1)',
      padding: '6px 12px',
      borderRadius: '4px',
      fontSize: '14px',
      fontWeight: '500',
      whiteSpace: 'nowrap',
      zIndex: '1000'
    });

    // Add to progress container
    this.controls.progressContainer.appendChild(this.timestampPopup);
  }

  createProgressBackground() {
    const bg = document.createElement('div');
    bg.className = 'progress-background';
    this.ui.progressContainer.insertBefore(bg, this.ui.progressBar);
    this.progressBackground = bg;
    bg.style.transition = 'background-color 0.5s ease';
  }

  bindEvents() {
    const wrapper = document.querySelector('.video-wrapper');
    const handler = this.handleUnifiedPointerEvent.bind(this);
    wrapper.addEventListener('pointerdown', handler, { passive: true });
    wrapper.addEventListener('pointermove', throttle(handler, 32), { passive: true });
    wrapper.addEventListener('pointerup', handler, { passive: true });
    wrapper.addEventListener('pointercancel', handler, { passive: true });

    // Listen for play/pause events to start/stop UI update loop
    this.video.addEventListener('play', () => this.startUIUpdates());
    this.video.addEventListener('pause', () => this.stopUIUpdates());
  }

  initKeyBindings() {
    document.addEventListener('keydown', this.handleKeyPress.bind(this));
  }

  handleKeyPress(e) {
    this.resetControlsTimeout();
    if (e.repeat) return;

    switch(e.code) {
      case 'Space':
        this.togglePlayPause();
        break;
      case 'KeyF':
        this.toggleFullscreen();
        break;
      case 'ArrowRight':
        this.handleArrowKey('right', e);
        break;
      case 'ArrowLeft':
        this.handleArrowKey('left', e);
        break;
      default:
        break;
    }
  }

  initActivityMonitoring() {
    const activityEvents = ['mousemove', 'click', 'touchstart', 'keydown'];
    activityEvents.forEach(eventName => {
      document.addEventListener(eventName, () => {
        this.showControls();
        this.resetControlsTimeout();
      }, { passive: true });
    });
  }

  resetControlsTimeout() {
    clearTimeout(this.controlsTimeout);
    this.controlsTimeout = setTimeout(() => {
      this.hideControls();
    }, 3000);
  }

  showControls() {
    if (this.controlsVisible && !this.fullscreenUIHidden) return;
    this.controlsVisible = true;
    this.ui.progressContainer.style.opacity = '1';
    if (this.timestampPopup) {
      this.timestampPopup.style.opacity = '1';
    }
  }

  hideControls() {
    if (!this.controlsVisible || !document.fullscreenElement) return;
    this.controlsVisible = false;
    this.fullscreenUIHidden = true;
    this.ui.progressContainer.style.opacity = '0';
    if (this.timestampPopup) {
      this.timestampPopup.style.opacity = '0';
    }
  }

  startUIUpdates() {
    if (!this.uiUpdateActive) {
      this.uiUpdateActive = true;
      const update = () => {
        if (this.uiUpdateActive) {
          this.updateUI();
          requestAnimationFrame(update);
        }
      };
      requestAnimationFrame(update);
    }
  }

  stopUIUpdates() {
    this.uiUpdateActive = false;
  }

  updateUI() {
    // Update progress bar
    if (this.video.duration) {
      const percent = (this.video.currentTime / this.video.duration) * 100;
      this.ui.progressBar.style.width = percent + '%';
    }
    // Update buffer bar
    if (this.video.buffered.length) {
      const bufferedEnd = this.video.buffered.end(this.video.buffered.length - 1);
      const bufferedPercent = (bufferedEnd / this.video.duration) * 100;
      this.ui.bufferBar.style.width = bufferedPercent + '%';
    }
    // Additional UI updates (like spinner or hue effects) can be applied here
  }

  togglePlayPause() {
    this.resetControlsTimeout();
    if (this.video.paused) {
      this.video.play().then(() => {
        this.showFastSeekAnimation('play');
      }).catch(err => console.error('Play error:', err));
    } else {
      this.video.pause();
      this.showFastSeekAnimation('pause');
    }
  }

  toggleFullscreen() {
    this.resetControlsTimeout();
    const wrapper = document.querySelector('.video-wrapper');
    if (!document.fullscreenElement) {
      wrapper.requestFullscreen().then(() => {
        this.showToast('Fullscreen');
        this.fullscreenUIHidden = false;
        this.showControls();
      }).catch(err => this.showToast('Fullscreen Error'));
    } else {
      document.exitFullscreen().then(() => {
        this.showToast('Windowed');
        this.fullscreenUIHidden = false;
        this.showControls();
      }).catch(err => this.showToast('Windowed Error'));
    }
  }

  handleArrowKey(direction, e) {
    const positions = {
      right: { x: window.innerWidth - 100, y: window.innerHeight / 2 },
      left: { x: 100, y: window.innerHeight / 2 }
    };

    if (this.state.arrowTimeout) {
      clearTimeout(this.state.arrowTimeout);
      this.state.arrowTimeout = null;
    }

    const tapCount = (this.state.multiTapState?.[direction] || 0) + 1;
    this.state.multiTapState = { ...this.state.multiTapState, [direction]: tapCount };

    if (tapCount === 2) {
      if (direction === 'right') {
        loadNextVideo();
        this.showFastSeekAnimation('right');
      } else {
        loadPreviousVideo();
        this.showFastSeekAnimation('left');
      }
      this.state.multiTapState[direction] = 0;
    } else {
      this.state.arrowTimeout = setTimeout(() => {
        const seconds = direction === 'right' ? 15 : -15;
        this.secsSeek(seconds);
        this.showFastSeekAnimation(direction);
        this.state.multiTapState[direction] = 0;
      }, 200);
    }
  }

  handleUnifiedPointerEvent(e) {
    if (e.target.closest('.progress-container')) {
      if (e.type === 'pointerdown') {
        this.handlePointerDown(e);
      } else if (e.type === 'pointermove') {
        this.handlePointerMove(e);
      } else if (e.type === 'pointerup' || e.type === 'pointercancel') {
        this.handlePointerUp(e);
      }
    }
  }

  handlePointerDown(e) {
    e.preventDefault();
    this.isDragging = true;
    this.showControls();
    this.ui.progressContainer.setPointerCapture(e.pointerId);
    this.seekToPosition(e.clientX);
    this.timestampPopup.style.display = 'block';
    this.timestampPopup.style.opacity = '1';
    this.timestampPopup.style.transform = 'translateX(-50%) translateY(-8px)';
    this.ui.progressBar.classList.add('dragging');
  }

  handlePointerMove(e) {
    if (!this.isDragging) return;
    
    const rect = this.ui.progressContainer.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const percent = Math.min(Math.max(0, offsetX / rect.width), 1);
    
    this.timestampPopup.style.left = `${percent * 100}%`;
    this.timestampPopup.textContent = formatTime(percent * this.video.duration);
  }

  handlePointerUp(e) {
    if (this.isDragging) {
      this.seekToPosition(e.clientX);
      this.isDragging = false;
      this.ui.progressContainer.releasePointerCapture(e.pointerId);
      this.ui.progressBar.classList.remove('dragging');
      this.timestampPopup.style.opacity = '0';
      this.timestampPopup.style.transform = 'translateX(-50%) translateY(0)';
      // Let CSS transition handle the hide animation
      setTimeout(() => this.timestampPopup.style.display = 'none', 300);
    }
  }

  seekToPosition(clientX) {
    const rect = this.ui.progressContainer.getBoundingClientRect();
    const offsetX = clientX - rect.left;
    const percent = Math.min(Math.max(0, offsetX / rect.width), 1);
    const newTime = percent * this.video.duration;
    
    this.video.currentTime = newTime;
    
    if (this.timestampPopup) {
      this.timestampPopup.textContent = formatTime(newTime);
      // Position as percentage relative to progress container
      this.timestampPopup.style.left = `${percent * 100}%`;
    }
  }

  showNotification(message, type = 'info') {
    const notificationsEl = document.getElementById('notifications-container');
    if (!notificationsEl) return;

    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
      <div class="notification-content">
        <div class="notification-message">${message}</div>
        <div class="notification-timestamp">${new Date().toLocaleTimeString()}</div>
      </div>
    `;

    notificationsEl.appendChild(notification);
    requestAnimationFrame(() => notification.classList.add('visible'));

    setTimeout(() => {
      notification.classList.add('exiting');
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  updateTimestampPopupPreview(offsetX) {
    const percent = offsetX / this.state.containerWidth;
    const time = this.video.duration * percent;
    
    this.timestampPopup.querySelector('.time-display').textContent = formatTime(time);
    this.miniProgress.style.width = `${percent * 100}%`;
    this.timestampPopup.style.left = `${offsetX}px`;

    // Animation system integration
    if (!this.timestampPopup.classList.contains('visible')) {
      this.timestampPopup.classList.remove('hidden');
      this.timestampPopup.classList.add('visible');
    }
  }

  hideTimestampPopup() {
    this.timestampPopup.classList.add('hidden');
    this.timestampPopup.classList.remove('visible', 'dragging');
    
    // Cleanup after animation
    this.timestampPopup.addEventListener('animationend', () => {
      this.timestampPopup.style.display = 'none';
    }, { once: true });
  }

  handlePopupDragMove(e) {
    if (this.state.isDraggingPopup) {
      // ... existing code ...
      this.timestampPopup.classList.add('dragging');
    }
  }

  updateAllUIColor() {
    const hue = this.currentHue;
    const elements = {
      progressBar: this.controls.progressBar,
      spinner: this.controls.spinner,
      timestampPopup: this.timestampPopup,
      progressBackground: this.progressBackground,
      playPauseAnimation: this.playPauseAnimation
    };

    // Common color properties
    const primaryColor = `hsl(${hue}, 70%, 50%)`;
    const secondaryColor = `hsla(${hue}, 70%, 35%, 0.8)`;
    const bgColor = `hsla(${hue}, 30%, 20%, 0.3)`;
    const textColor = `hsl(${hue}, 70%, 95%)`;

    // Batch update elements
    Object.entries(elements).forEach(([key, element]) => {
      if (!element) return;
      
      switch(key) {
        case 'progressBar':
          element.style.backgroundColor = primaryColor;
          break;
        case 'spinner':
          element.style.borderTopColor = primaryColor;
          break;
        case 'timestampPopup':
          element.style.backgroundColor = `hsla(${hue}, 70%, 50%, 0.2)`;
          element.style.border = `2px solid ${secondaryColor}`;
          element.style.color = textColor;
          break;
        case 'progressBackground':
          element.style.backgroundColor = bgColor;
          break;
        case 'playPauseAnimation':
          element.style.color = primaryColor;
          break;
      }
    });
  }

  showFastSeekAnimation(direction) {
    const messages = {
      left: '⏪ Rewound 15s',
      right: '⏩ Fast-forwarded 15s',
      play: '▶️ Play',
      pause: '⏸ Paused'
    };
    
    this.showNotification(messages[direction], 'info');
    
    // Keep existing visual animation if needed, but remove duplicate feedback
    // ... rest of existing animation code ...
  }

  secsSeek(seconds) {
    this.video.currentTime = Math.min(Math.max(0, this.video.currentTime + seconds), this.video.duration);
  }
}

export default UIController;

================
File: videoController.js
================
import eventEmitter from './utils/EventEmitter.js';
import { VideoError, ProviderError } from './utils/ErrorHandler.js';
import { VIDEO } from './config/config.js';

/**
 * Manages video playback and state
 */
export class VideoController {
    constructor(videoElement, providers = []) {
        this.video = videoElement;
        this.providers = providers;
        this.currentProvider = 0;
        this.currentCid = null;
        this.debug = true; // Set to false to disable logging
        this.initialize();
    }

    /**
     * Initialize video controller
     */
    initialize() {
        this.setupVideoElement();
        this.setupEventListeners();
    }

    /**
     * Set up video element properties
     */
    setupVideoElement() {
        this.video.preload = 'auto';
        this.video.playsInline = true;
        this.video.setAttribute('crossorigin', 'anonymous');
    }

    /**
     * Set up event listeners
     */
    setupEventListeners() {
        // Buffer events
        this.video.addEventListener('canplay', () => {
            eventEmitter.emit('video:can-play');
        });

        // Error handling
        this.video.addEventListener('error', (e) => {
            const error = new VideoError(
                'Video playback error',
                this.video.error?.code,
                true
            );
            eventEmitter.emit('video:error', error);
        });
    }

    /**
     * Load video from given ID/CID
     * @param {string} videoId - Video ID or CID
     * @returns {Promise<void>}
     */
    async load(videoId) {
        this.currentCid = videoId;
        this.currentProvider = 0;
        await this.tryLoadWithProvider(videoId);
    }

    /**
     * Try loading video with current provider
     * @param {string} videoId - Video ID or CID
     * @returns {Promise<void>}
     */
    async tryLoadWithProvider(videoId) {
        if (this.currentProvider >= this.providers.length) {
            throw new VideoError('All providers failed', 'PROVIDER_FAILURE', false);
        }

        const provider = this.providers[this.currentProvider];

        try {
            const response = await provider.fetch(videoId, 0, 0);
            await this.setupVideoSource(response);
            
            // Store last working provider
            const cache = JSON.parse(localStorage.getItem(VIDEO.CID_VALID_CACHE_KEY) || '{}');
            cache[videoId] = {
                ...cache[videoId],
                lastWorkingProvider: provider.name,
                timestamp: Date.now()
            };
            localStorage.setItem(VIDEO.CID_VALID_CACHE_KEY, JSON.stringify(cache));
        } catch (error) {
            console.warn(`Provider ${provider.name} failed:`, error);
            // Emit provider error for factory handling
            eventEmitter.emit('provider:error', {
                error: new ProviderError(error.message, provider.name),
                context: { videoId, currentProvider: this.currentProvider }
            });
            this.currentProvider++;
            return this.tryLoadWithProvider(videoId);
        }
    }

    /**
     * Get current CID
     * @returns {string|null} Current content ID
     */
    getCurrentCid() {
        return this.currentCid;
    }

    /**
     * Generate provider URL
     * @param {string} cid Content ID
     * @param {string} preferredProvider Preferred provider name 
     * @returns {string} Provider URL
     */
    generateProviderUrl(cid, preferredProvider) {
        const provider = this.providers.find(p => p.name === preferredProvider) 
            || this.providers[this.currentProvider];
            
        if (!provider) {
            throw new Error('No valid provider available');
        }

        // Use the provider's URL builder if available, otherwise construct default URL
        if (provider.getUrl) {
            return provider.getUrl(cid);
        }

        // Default URL construction (matches factory's buildProviderUrl logic)
        const providerName = provider.name.toLowerCase();
        if (providerName === 'ipfs.io') {
            return `https://ipfs.io/ipfs/${cid}`;
        }
        return ["dweb.link", "flk-ipfs.xyz"].includes(providerName)
            ? `https://${cid}.ipfs.${providerName}`
            : `https://ipfs.${providerName}/ipfs/${cid}`;
    }

    /**
     * Set up video source with response data
     * @param {Response} response - Fetch response
     * @returns {Promise<void>}
     */
    async setupVideoSource(response) {
        // Check for video mime type
        const contentType = response.headers.get('content-type');
        if (!contentType?.includes('video/')) {
            throw new Error('Invalid content type');
        }

        const blob = await response.blob();
        const url = URL.createObjectURL(blob);

        return new Promise((resolve, reject) => {
            const cleanup = () => {
                this.video.removeEventListener('loadedmetadata', onLoad);
                this.video.removeEventListener('error', onError);
            };

            const onLoad = () => {
                cleanup();
                resolve();
            };

            const onError = () => {
                cleanup();
                URL.revokeObjectURL(url);
                reject(new Error('Failed to load video'));
            };

            this.video.addEventListener('loadedmetadata', onLoad);
            this.video.addEventListener('error', onError);
            this.video.src = url;
        });
    }

    /**
     * Get current playback state
     * @returns {Object} - Playback state
     */
    getState() {
        return {
            currentTime: this.video.currentTime,
            duration: this.video.duration,
            paused: this.video.paused,
            ended: this.video.ended,
            volume: this.video.volume,
            muted: this.video.muted,
            playbackRate: this.video.playbackRate,
            currentProvider: this.providers[this.currentProvider]?.name,
            currentCid: this.currentCid
        };
    }

    /**
     * Clean up resources
     */
    dispose() {
        if (this.video.src) {
            URL.revokeObjectURL(this.video.src);
        }
        this.video.src = '';
    }
}

================
File: videoSources.js
================
import eventEmitter from './utils/EventEmitter.js';
import { VIDEO } from './config/config.js';

/**
 * Manages video sources and caching
 */
class VideoSourceManager {
    constructor() {
        this.validCids = new Map();
        this.loadCachedCids();
    }

    /**
     * Load cached CIDs from localStorage
     */
    loadCachedCids() {
        try {
            const cached = localStorage.getItem(VIDEO.CID_VALID_CACHE_KEY);
            if (cached) {
                const { cids, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < VIDEO.CID_VALIDITY_DURATION) {
                    cids.forEach(({ cid, metadata }) => {
                        this.validCids.set(cid, metadata);
                    });
                }
            }
        } catch (error) {
            console.warn('Failed to load cached CIDs:', error);
        }
    }

    /**
     * Save valid CIDs to localStorage
     */
    saveCachedCids() {
        try {
            const cids = Array.from(this.validCids.entries()).map(([cid, metadata]) => ({
                cid,
                metadata
            }));

            localStorage.setItem(VIDEO.CID_VALID_CACHE_KEY, JSON.stringify({
                cids,
                timestamp: Date.now()
            }));
        } catch (error) {
            console.warn('Failed to save CID cache:', error);
        }
    }

    /**
     * Validate a video CID
     * @param {string} cid - Content ID to validate
     * @returns {Promise<boolean>} - Whether the CID is valid
     */
    async validateCid(cid) {
        // Check cache first
        if (this.validCids.has(cid)) {
            return true;
        }

        try {
            const metadata = await this.fetchMetadata(cid);
            if (this.isValidVideoMetadata(metadata)) {
                this.validCids.set(cid, metadata);
                this.saveCachedCids();
                return true;
            }
        } catch (error) {
            console.warn('CID validation failed:', error);
        }

        return false;
    }

    /**
     * Fetch metadata for a CID
     * @param {string} cid - Content ID
     * @returns {Promise<Object>} - Video metadata
     */
    async fetchMetadata(cid) {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), VIDEO.LOAD_TIMEOUT);

        try {
            const response = await fetch(`https://ipfs.io/api/v0/dag/get?arg=${cid}`, {
                signal: controller.signal
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const metadata = await response.json();
            return metadata;
        } finally {
            clearTimeout(timeout);
        }
    }

    /**
     * Check if metadata indicates valid video content
     * @param {Object} metadata - Video metadata
     * @returns {boolean} - Whether metadata is valid
     */
    isValidVideoMetadata(metadata) {
        // Check for required fields
        if (!metadata || typeof metadata !== 'object') {
            return false;
        }

        // Must have either Links or Data
        if (!metadata.Links && !metadata.Data) {
            return false;
        }

        // If has Links, must contain video file
        if (metadata.Links) {
            const hasVideoFile = metadata.Links.some(link =>
                link.Name.match(/\.(mp4|webm|mov)$/i) &&
                link.Size > 0
            );
            if (!hasVideoFile) {
                return false;
            }
        }

        // If has Data, must be video content type
        if (metadata.Data) {
            const isVideo = metadata.Data.some(chunk =>
                chunk.type?.startsWith('video/') ||
                chunk.contentType?.startsWith('video/')
            );
            if (!isVideo) {
                return false;
            }
        }

        return true;
    }

    /**
     * Get metadata for a valid CID
     * @param {string} cid - Content ID
     * @returns {Object|null} - Video metadata or null if not found
     */
    getMetadata(cid) {
        return this.validCids.get(cid) || null;
    }

    /**
     * Clear expired CIDs from cache
     */
    clearExpiredCids() {
        const now = Date.now();
        let hasExpired = false;

        for (const [cid, metadata] of this.validCids.entries()) {
            if (metadata.timestamp && (now - metadata.timestamp > VIDEO.CID_VALIDITY_DURATION)) {
                this.validCids.delete(cid);
                hasExpired = true;
            }
        }

        if (hasExpired) {
            this.saveCachedCids();
        }
    }

    /**
     * Get list of valid CIDs
     * @returns {string[]} - Array of valid CIDs
     */
    getValidCids() {
        this.clearExpiredCids();
        return Array.from(this.validCids.keys());
    }
}

// Create and export singleton instance
const videoSourceManager = new VideoSourceManager();
export default videoSourceManager;

// Register cleanup on page unload
window.addEventListener('unload', () => {
    videoSourceManager.saveCachedCids();
});
